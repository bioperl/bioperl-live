<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE faq SYSTEM "faq.dtd">
<faq>
  <header>
    <title>Bioperl FAQ</title>
    <version>1.4.0</version>
    <author>Jason Stajich &lt;jason@bioperl.org&gt;</author>
    <author>Brian Osborne &lt;brian_osborne@cognia.com&gt;</author>
    <author>Heikki Lehvaslaiho &lt;heikki@ebi.ac.uk&gt;</author>
  </header>
  <section id="0">
    <section_name>About this FAQ</section_name>
    <q id="1">
      <question>What is this FAQ?</question>
      <answer>
	<p>It is the list of Frequently Asked Questions about Bioperl.</p>
      </answer>
    </q>
    <q id="2">
      <question>How is it maintained?</question>
      <answer>
	<p>This FAQ was generated using a Perl script and an XML file. All the files are in the Bioperl distribution directory doc/faq. <strong>So do not edit this file!</strong> Edit file faq.xml and run:
	</p>
	<code>% faq.pl -text faq.xml
	</code>
	<p>The XML structure was originally used by the Perl XML project. Their website seems to have vanished, though. The XML and modifying scripts were copied from Michael Rodriguez's web site <a href="http://www.xmltwig.com/xmltwig/XML-Twig-FAQ.html">http://www.xmltwig.com/xmltwig/XML-Twig-FAQ.html</a> and modified to our needs.
	</p>
      </answer>
    </q>
  </section>
  <section id="1">
    <section_name>Bioperl in general</section_name>
    <q id="1">
      <question>What is Bioperl?</question>
      <answer><p>Bioperl is a tookit of perl modules useful in building bioinformatics solutions in perl. It is built in an object-oriented manner so that many modules depend on each other to achieve a task. The collection of modules in the bioperl-live repository consist of the core of the functionality of bioperl. Additionally auxiliary modules for creating graphical interfaces (bioperl-gui), persistent storage in RDMBS (bioperl-db), running and parsing the results from hundreds of bioinformatics applications (bioperl-run), software to automate bioinformatic analyses (bioperl-pipeline), and CORBA bridges to the BioCORBA (<a href="http://www.biocorba.org">http://www.biocorba.org</a>) specification (bioperl-corba-server and bioperl-corba-client) are all available as CVS modules in our repository.</p>
      </answer>
    </q>
    <q id="2">
      <question>Where do I go to get the latest release?</question>
      <answer><p>You can always get our releases from <a href="ftp://bioperl.org/pub/DIST">ftp://bioperl.org/pub/DIST</a>. Official releases will be noted on the website <a href="http://bioperl.org">http://bioperl.org</a>.</p>
      </answer>
    </q>
    <q id="3">
      <question>What is the difference between 0.9.x and 0.7.x? What do you mean developer release?</question>
      <answer><p>0.7.X series (0.7.0, 0.7.2) were all released in 2001 and were stable releases on 0.7 branch.  This means they had a set of functionality that is maintained throughout (no experimental modules) and were guaranteed to have all tests and subsequent bug fix releases with the 0.7 designation would not have any API changes.</p>
	<p>The 0.9.X series was our first attempt at releasing so called developer releases.  These are snapshots of the actively developed code that at a minimum pass all our tests.</p>
	<p>But really, you should be using version 1.21 or greater!</p>
      </answer>
    </q>
    <q id="4">
      <question>Is it BioPerl, bioperl, bio.perl.org, Bioperl?  What's the deal?</question>
      <answer>Well, the perl.org guys granted us use of bio.perl.org. We prefer to be called Bioperl or BioPerl (unlike our Biopython friends).  We're part of the Open Bioinformatics Foundation (OBF) and so as part of the Bio{*} toolkits we prefer the Bioperl spelling.  But we're not really all that picky so no worries. 
      </answer>
    </q>
    <q id="2">
      <question>How do I figure out how to use a module?</question>
      <answer><p>A good list of the documentation can be found at <a href="http://bio.perl.org/Core/Latest/modules.html">http://bio.perl.org/Core/Latest/modules.html</a>. Read the embedded perl documentation (Plain Old Documentation - POD) that is part of every modules.  Do:</p>
	<code>% perldoc MODULE
	</code>
	<p>Careful - spelling and case counts!</p>
	<p>The bioperl tutorial - bptutorial.pl - provided in the root directory of the bioperl release will also provide a good introduction.  You may also find useful documentation in the form of a HOWTO in the bioperl package or at <a href="http://www.bioperl.org/HOWTOs">http://www.bioperl.org/HOWTOs</a>. There are links to tutorials off the bioperl website that may provide some additional help.</p>
	<p>There are also many scripts in the examples/ and scripts/ directories that could be useful - see bioscripts.pod for a brief description of all of them.</p>
	<p>Additionally we have written many tests for our modules, you can see test data and example usage of the modules in these tests - look in the test dir (called 't').</p>
      </answer>
    </q>
    <q id="6">
      <question>I'm interested in the bleeding edge version of the code, where can I get it?</question>
      <answer>
	<p>Go to <a href="http://cvs.bioperl.org">http://cvs.bioperl.org</a> and you'll see instructions on how to get the CVS code.
	</p>
	<p>Basically:</p>
	<code>% cvs -d :pserver:cvs@cvs.bioperl.org:/home/repository/bioperl login
	</code>
	<p>Enter 'cvs' for the password</p>
	<code>% cvs -d :pserver:cvs@cvs.bioperl.org:/home/repository/bioperl co bioperl_all
	</code>
      </answer>
    </q>
    <q id="7">
      <question>Who uses this toolkit?</question>
      <answer>
	<p>Lots of people. Sanger Centre, EBI, many large and small academic laboratories, large and small pharmaceutical companies. All the developers on the bioperl list use the toolkit in some capacity on a regular basis.</p>
	<p>The Genquire annotation system (<a href="http://www.bioinformatics.org/Genquire/">http://www.bioinformatics.org/Genquire/</a>) and Ensembl (<a href="http://www.ensembl.org/">http://www.ensembl.org/</a>) use bioperl as the basis for their implementation.
	</p>
      </answer>
    </q>
    <q id="8">
      <question>How should I cite Bioperl?</question>
      <answer>
	<p>Please cite it as:</p><p>
	  Stajich JE, Block D, Boulez K, Brenner SE, Chervitz SA,  
	  Dagdigian C, Fuellen G, Gilbert JGR, Korf I, Lapp H, 
	  Lehvaslaiho H, Matsalla C, Mungall CJ, Osborne BI,
	  Pocock MR, Schattner P, Senger M, Stein LD, Stupka ED, 
	  Wilkinson M, Birney E.
	  The Bioperl Toolkit: Perl modules for the life sciences. 
	  Genome Research. 2002 Oct;12(10):1161-8.
	</p>
      </answer>
    </q>
    <q id="9">
      <question>What are the license terms for Bioperl?</question>
      <answer>
	<p>Bioperl is licensed under the same terms as Perl itself which is the Perl Artistic License. You can see more information on that license at <a href="http://www.perl.com/pub/a/language/misc/Artistic.html">http://www.perl.com/pub/a/language/misc/Artistic.html</a> and <a href="http://www.opensource.org/licenses/artistic-license.html">http://www.opensource.org/licenses/artistic-license.html</a>.
	</p>
      </answer>
    </q>
    <q id="10">
      <question>I want to help, where do I start?</question>
      <answer>
	<p>Bioperl is a pretty diverse collection of modules which has grown from the direct needs of the developers participating in the project.  So if you don't have a need for a specific module in the toolkit it becomes hard to just describe ways it needs to be expanded or adapted.  One area, however is the development of stand alone scripts which use bioperl components for common tasks.  Some starting points for script: find out what people in your institution do routinely that a shortcut can be developed for.  Identify modules in bioperl that need easy intefaces and write that wrapper - you'll learn how to use the module inside and out. We always need people to help fix bugs - check the Bugzilla bug tracking system (<a href="http://www.bioperl.org/Bugs">http://www.bioperl.org/bugs</a>).</p>
      </answer>
    </q>
    <q id="11">
      <question>I've got an idea for a module how do I contribute it?</question>
      <answer>
	<p>We suggest the following.  Post your idea to the bioperl list, bioperl-l@bioperl.org. If it is a really new idea consider taking us through your thought process.  We'll help you tease out the necessary information such as what methods you'll want and how it can interact with other bioperl modules.  If it is a port of something you've already worked on, give us a summary of the current methods.  Make sure there is an interface to the module, not just an implementation (see the biodesign.pod for more info) and make sure there will be a set of tests that will be in the t/ directory to insure that your module is tested.</p>
      </answer>
    </q>
    <q id="12">
      <question>Why can't I easily get a list of all the methods a object can call?</question>
      <answer>
	<p>This a problem with perl, not only with bioperl. To list all the methods, you have to walk the inheritance tree and standard perl is not able to do it. As usual, help can be found in the CPAN. Install the CPAN module Class::Inspector and put the following script 'perlmethods' into your path and run it, e.g, <code>>perlmethods Bio::Seq</code>.</p>
	<code>
	  #!/usr/bin/perl -w
	  use Class::Inspector;
	  $class = shift || die "Usage: methods perl_class_name\n";
	  eval "require $class";
	  print join ("\n", sort @{Class::Inspector->methods($class,'full','public')}),
	  "\n";
	</code>
      </answer>
    </q>
    <q id="13">
     <question>Can you explain the Object Model design and rationale?</question>
     <answer>
<p>
There is complicated answer to these questions.  Simply put, this is a toolkit which has grown organically.  The goals and user audience has evolved.  Some decisions have been made and we have been forced to live by them rather than destroy backwards compatability.  In addition there are different philosophies of software development.  The major developers on the project have tried to impose a set of standards on the code so that the project can be coordinated without every commit being cleared by a few key individuals.  See Eric S Raymond's "The Cathedral and the Bazaar" for different styles of running an open-source project - we are clearly on the Bazaar end.  The biodesign.pod document in the bioperl distribution and available on the website <a href="http://bioperl.org/Core/Lates/biodesign.html">http://bioperl.org/Core/Lates/biodesign.html</a> should detail more about specific design goals.
</p>

<p>
The clear consensus of the project developers is that Bioperl should be consistent.  This may cause us to pay the price of some copy+paste of code (the Get/Set accessor methods being a sore spot for some) and the lack of using AUTOLOAD.  By being consistent we hope that someone can grok the gist of a module from the basic documentation, see example code, and get a set of methods from the API documetation.  We aim to make the core object design easy to understand.  This has not been realized by any stretch of the imagination as the toolkit has well over 1000 modules in bioperl-live and bioperl-run alone.
</p>
<p>
That said we do want to improve things.  We want to experiment with newer modules which made Perl more Object-Oriented.  We have high hopes for some of the promises of Perl6.  To try and realize this goal we are encouraging developers to play with new object models in a bioperl-experimental project.  
</p>
<p>
Some useful discussion on the mailing list can be found at this node <a
href="http://bioperl.org/pipermail/bioperl-l/2003-December/014406.html">http://bioperl.org/pipermail/bioperl-l/2003-December/014406.html</a>.   We encourage you to participate in the discussion and to join in the development process either on existing Bioperl code or the bioperl-experimental code if you have a particular interest in making the toolkit more Object-Oriented.
  </p>
  </answer>
  </q>
  </section>
  <section id="2">
    <section_name>Sequences</section_name>
    <q id="1">
      <question>How do I parse a sequence file?</question>
      <answer>
	<p>Use the Bio::SeqIO system.  This will create Bio::Seq objects for you.  See the tutorial bptutorial.pl for more information or the <a href="http://www.bioperl.org/HOWTOs/html/SeqIO.html">SeqIO HOWTO</a> or the documentation for Bio::SeqIO (e.g. 'perldoc SeqIO.pm').</p>
      </answer>
    </q>
    <q id="2">
      <question>I can't get sequences with Bio::DB::GenBank any more, why not?</question>
      <answer>
	<p>NCBI changed the web CGI script that provided this access.  You must be using bioperl &lt;= 0.7.2.  The developer release 0.9.3 contains this fix as does the 1.0 release.</p>
      </answer>
    </q>
    <q id="3">
      <question>How can I get NT_ or NM_ or NP_ accessions from NCBI
	(Reference Sequences)?</question>
      <answer>
	<p>Use Bio::DB::RefSeq not Bio::DB::GenBank or Bio::DB::GenPept when you are retrieving these accessions. This is still an area of active development because the data providers have not provided the best interface for us to query.  EBI has provided a mirror with their dbfetch system which is accessible through the Bio::DB::RefSeq object however, there are cases where NT_ accessions will not be retrievable.</p>
      </answer>
    </q>
    <q id="4">
      <question>How can I use SeqIO to parse sequence data to or from a string?</question>
      <answer>
	<p>From a string:</p>
	<code>
	  use IO::String;
	  use Bio::SeqIO;
	  my $stringfh = new IO::String($string);
	  
	  my $seqio = new Bio::SeqIO(-fh =&gt; $stringfh, 
	                             -format =&gt; 'fasta');
	  while( my $seq = $seqio-&gt;next_seq ) { 
	    # process each seq
	  }
	</code>
	<p>And here is how to write to a string:</p>
	<code>
	  use IO::String;
	  use Bio::SeqIO;
	  my $s;
	  my $io = IO::String->new(\$s);
	  my $seqOut = new Bio::SeqIO(-format =&gt;'swiss', -fh =&gt; $io);
	  $seqOut->write_seq($seq1);
	  print $s; # $s contains the record
	</code>
      </answer>
    </q>
    <q id="5">
      <question>I'm using Bio::Index::Fasta in order to retrieve sequences from my indexed fasta file but I keep seeing ">> MSG: Did not provide a valid Bio::PrimarySeqI object" when I call fetch() followed by SeqIO::write_seq(). Why?
      </question>
      <answer>
	<p>It's likely that fetch() didn't retrieve a Bio::Seq object. There are few possible explanations but the most common cause is that the id you're passing to fetch() is not the key to that sequence in the index. For example, if the fasta header is ">gi|12366" and your id is "12366" fetch() won't find the sequence, it expects to see "gi|12366". You need to use the get_id() method to specify the key, like this:</p>
	<code>
	  $inx = Bio::Index::Fasta->new(-filename =&gt;$indexname);
	  $inx = id_parser(\&amp;get_id);
	  $inx->make_index($fastaname);
	  
	  sub get_id {
	  my $header = shift;
	  $header =~ /^>gi\|(\d+)/;
	  $1;
	  }
	</code>
	The same issue arises when you use Bio::DB::Fasta, but in that case the code might look like this:
	<code>
	  $inx = Bio::DB::Fasta->new($fastaname,-makeid =&gt;\&amp;get_id);
	</code>	 
      </answer>
    </q>
    <q id="6">   
      <question>
	<p>I'm using Bio::DB::GenBank to query Genbank and I'm certain that the id is there but I'm seeing the error "MSG: acc does not exist".</p>
      </question>
	<answer>
	  <p>This bug in versions 1.2 and 1.2.1, but it is fixed in 1.2.2. Either upgrade to 1.2.2 or edit Bio/DB/GenBank.pm and change 'protein' to 'nucleotide' in the BEGIN block.</p>
	</answer>
    </q>
  </section>
  <section id="3">
    <section_name>Report parsing</section_name>
    <q id="1">
      <question>I want to parse BLAST, how do I do this?</question>
      <answer>
	<p>Bioperl only supports one approach, Bio::SearchIO, as of verion 1.1. There are other Blast parsing modules in the package but they remain just to support older code.</p>
	<p>SearchIO supports BLAST, PSIBLAST, HMMER, WABA, and fasta report parsing.  The bptutorial provides an example of how to use this system as well as the documentation in the Bio::SearchIO system. There is also a <a href="http://www.bioperl.org/HOWTOs/html/SearchIO.html">SearchIO HOWTO</a>.</p>
      </answer>
    </q>
    <q id="2">
      <question>What was wrong with Bio::Tools::Blast?</question>
      <answer>
	<p>Bio::Tools::Blast* is no longer supported, as of Bioperl version 1.1. Nothing is really wrong with it, it has just been outgrown by a more generic approach to reports.  This generic approach allows us to just write pluggable modules for fasta and Blast parsing while using the same framework.  This is completely analogous to the Bio::SeqIO system of parsing sequence files.  However, the objects produced are of the Bio::Search rather than Bio::Seq variety.</p>
      </answer>
    </q>
    <q id="3">
      <question>I want to parse FastA or NCBI -m7 (XML) format, how do I do this?</question>
      <answer>
	<p>It is as simple as parsing text BLAST results - you simply need to specify the format as "fasta" or "blastxml" and the parser will load the appropriate module for you.  You can use the exact logic and code for all of these formats as we have generalized the modules for sequence database searching.</p>
      </answer>
    </q>
    <q id="4">
      <question>Let's say I want to do pairwise alignments of 2 sequences. How can I do this?</question>
      <answer>
	<p>Look at Bio::Factory::EMBOSS to see how to use the 'water' and 'needle' alignment programs that are part of the EMBOSS suite.</p>
	<p>Additionally you can use the pSW module that is part of the bioperl-ext package (distributed separated at <a href="ftp://bioperl.org/pub/DIST">ftp://bioperl.org/pub/DIST</a>). However note this only does protein alignments and is no longer a supported module.  Instead the EMBOSS implementation is the the best path ahead unless someone else wants to provide an Inline::C implementation.
	</p>
      </answer>
    </q>
    <q id="5">
      <question>I'm using Bio::Search* and its frame() to parse Blast but I'm seeing 0, 1, or 2 instead of the expected -3, -2, -1, +1, +2, +3. Why am I seeing these different numbers and how do I get the frame according to Blast?
      </question>
      <answer>
	<p>These are GFF frames - so +1 is 0 in GFF, -3 will be encoded with a frame of 2 with the strand being set to -1 (for more on GFF see <a href="http://www.sanger.ac.uk/Software/formats/GFF/GFF_Spec.shtml">http://www.sanger.ac.uk/Software/formats/GFF/GFF_Spec.shtml</a>).
	</p>
	<p>Frames are relative to the hit or query sequence so you need to query it based on sequence you are interested in:</p>
	<code>$hsp-&gt;hit-&gt;strand();
	  $hsp-&gt;hit-&gt;frame();
	</code>
	<p>or</p>
	<code>$hsp-&gt;query-&gt;strand();
	  $hsp-&gt;query-&gt;frame();
	</code>
	<p>So the value according to a blast report of -3 can be constructed as:</p>
	<code>my $blastvalue = ($hsp-&gt;query-&gt;frame + 1) * $hsp-&gt;query-&gt;strand;
	</code>
      </answer>
    </q>
    <q id="6">
      <question>How do I tell BLAST to search multiple database using Bio::Tools::Run::StandAloneBlast?
      </question>
      <answer>
	<p>Put the names of the databases in a variable. like so:
	</p>
	<code>
	  my $dbs = '"/dba/BMC.fsa /dba/ALC.fsa /dba/HCC.fsa"';
	  my @params = ( d           => "$dbs",
	  program     => "BLASTN",
	  _READMETHOD => "Blast",
	  outfile     => "$dir/est.bls" );
	  
	  my $factory = Bio::Tools::Run::StandAloneBlast->new(@params);
	  my $seqio = Bio::SeqIO->new(-file=>'t/amino.fa',-format => 'Fasta' );
	  my $seqobj = $seqio->next_seq();
	  $factory->blastall($seqobj);
	</code>
      </answer>
    </q>
    <q id="7">
      <question>Does SearchIO parse the HTML output file that BLAST can create?</question>
      <answer><p>Yes, with a twist. You can modify SearchIO's _readline() method such that it reads in the HTML and strips it of tags using the StripHTML module:</p>
	<code>
	  use Bio::SearchIO;
	  use Bio::SearchIO::blast;
	  use HTML::Strip;
	  
	  my $hs = new HTML::Strip;
	  
	  # replace the blast parser's _readline method with one that
	  # auto-strips HTML:
	  
	  sub Bio::SearchIO::blast::_readline {
	    my ($self, @args) = @_;
	    return $hs->parse($self->SUPER::_readline(@args));
	  }
	  
	  $io = new Bio::SearchIO(-file => "etc.bls", -format => "blast");
	  # etc ...
	</code>
      </answer>
    </q>
    <q id="8">
      <question><p>Can I get domain number from hmmpfam or hmmsearch output? E.g.</p>
	<code>
	  SH2_5: domain 2 of 2, from 349 to 432: score 104.4, E = 1.9e-26
	</code>
      </question>
	<answer>
	  <p>Not directly but you can compute it since the domains are numbered by their order on the protein:</p>
	  <code>
	    my @domains = $hit->domains;
	    my $domainnum = 1;
	    my $total = scalar @domains;
	    foreach my $domain ( sort { $a-&gt;start &lt;=&gt; $b-&gt;start } $hit-&gt;domains ) {
	      print "domain $domainnum of $total,\n";
	      $domainnum++;
	    }
	  </code>
	</answer>
    </q>
  </section>
  <section id="4">
    <section_name>Utilities</section_name>
    <q id="1">
      <question>How do I find all the ORFs in a nucleotide sequence? Antigenic sites in a protein? Calculate nucleotide melting temperature? Find repeats?</question>
      <answer>
	<p>In fact, none of these functions are built into Bioperl but they are all available in the EMBOSS package (<a href="http://www.emboss.org/">http://www.emboss.org/</a>), as well as many others. The Bioperl developers created a simple interface to EMBOSS such that any and all EMBOSS programs can be run from within Bioperl. See Bio::Factory::EMBOSS for more information.
	</p>
	<p>If you can't find the functionality you want in Bioperl then make sure to look for it in EMBOSS, these packages integrate quite gracefully with Bioperl. Of course, you will have to install EMBOSS to get this access.
	</p>
	<p>In addition, Bioperl after version 1.0.1 contains the Pise/Bioperl modules. The Pise package (http://www-alt.pasteur.fr/~letondal/Pise) was designed to provide a uniform interface to bioinformatics applications, and currently provides wrappers to greater than 250 such applications! Included amongst these wrapped apps are HMMER, Phylip, BLAST, GENSCAN, even the EMBOSS suite. Use of the Pise/Bioperl modules does not require installation of the Pise package.
	</p>
      </answer>
    </q>
    <q id="2">
      <question>How do I do motif searches with Bioperl? Can I do "find all sequences that are 75% identical" to a given motif?</question>
      <answer>
	<p>There are a number of approaches. Within Bioperl take a look at Bio::Tools::SeqPattern. Or, take a look at the TFBS package, at <a href="http://forkhead.cgb.ki.se/TFBS">http://forkhead.cgb.ki.se/TFBS</a> (Transcription Factor Binding Site). This Bioperl-compliant package specializes in pattern searching of nucleotide sequence using matrices.</p>
	<p>It's also conceivable that the combination of Bioperl and Perl's regular expressions could do the trick. You might also consider the CPAN module String::Approx (this module addresses the percent match query), but experienced users question whether its distance estimates are correct, the Unix agrep command is thought to be faster and more accurate.  Finally, you could use EMBOSS, as discussed in the previous question (or you could use Pise to run EMBOSS applications). The relevant programs would be fuzzpro or fuzznuc.
	</p>
      </answer>
    </q>
    <q id="3">
      <question>Can I query MEDLINE or other bibliographic repositories using Bioperl?</question>
      <answer>
	<p>Yes! The solution lies in Bio::Biblio*, a set of modules that provide access to MEDLINE and OpenBQS-compliant servers using SOAP. See Bio/Biblio.pm, scripts/biblio.PLS, or examples/biblio/* for details and example code.</p>
      </answer>
    </q>
  </section>
  <section id="5">
    <section_name>Annotations and Features</section_name>
    <q id="1">
      <question>I get the warning "(old style Annotation) on new style Annotation::Collection".  What is wrong?
      </question>
      
      <answer><p>This is because we have transitioned from the <tt>add_Comment/each_Comment, add_Reference/each_Reference</tt> style to <tt>add_Annotation('comment', $ann)/get_Annotations('comment)</tt>. Please update your code in order to avoid seeing these warning messages.</p>
	
        <p>The objects have also changed from the Bio::Annotation object to the Bio::Annotation::Collection object, starting with v. 1.0. This is a more general and extensible system.  In the future the Reference objects will likely be implemented by the Bio::Biblio system but we hope to maintain a compatible API for these. 
        </p>
      </answer>
    </q>
    <q id="2">
      <question>How do I retrieve all the features from a Sequence?  How about all the features which are exons or have a /note field that contains a certain gene name?
      </question>
      <answer>
	<p>To get all the features:</p>
	<code>my @features = $seq-&gt;all_SeqFeatures();
	</code>
	<p>To get all the features filtering on only those which have the primary tag 'exon'.</p>
	<code>my @genes = grep { $_-&gt;primary_tag eq 'exon'} 
	  $seq-&gt;all_SeqFeatures();
	</code>
	<p>To get all the features filtering on this which have the tag 'note' and within the note field contain the requested string <i>$noteval</i>.</p>
	<code>
	  my @f_with_note = grep { 
	  my @a = $_-&gt;has_tag('note') ?
	  $_-&gt;each_tag_value('note') : (); 
	  grep { /$noteval/ } @a; 
	  }  $seq-&gt;all_SeqFeatures(); 
	</code>
      </answer>
    </q>
    <q id="3">
      <question>How do I parse the CDS join() or complement() statements in Genbank or EMBL files to get the sub-locations, like the coordinates "45" and "122" in "join(45..122,233..267)"?
      </question>
      <answer>
	<p>You could use primary_tag() to find the CDS features and the Location::SplitLocationI object to get the coordinates:</p>
	<code>
	  foreach my $feature ($seqobj->top_SeqFeatures){
	    if ( $feature-&gt;location-&gt;isa('Bio::Location::SplitLocationI') 
	  &amp;&amp; $feature-&gt;primary_tag eq 'CDS' )  {
	      foreach my $location ( $feature-&gt;location-&gt;sub_Location ) {
	        print $location-&gt;start . ".." . $location-&gt;end . "\n";
	      }
	    }
	  }  
	</code>
      </answer>
    </q>
    <q id="4">
      <question>How do I retrieve a nucleotide coding sequence when I have a protein gi number?
      </question>
      <answer>
	<p>You could go through the protein's feature table and find the 'coded_by' value. The trick is to associate the coded_by nucleotide coordinates to the nucleotide entry, which you'll retrieve using the accession number from the same feature.
	</p>
	<code>
	  my $gp = new Bio::DB::GenPept;
	  my $gb = new Bio::DB::GenBank;
	  # factory to turn strings into Bio::Location objects
	  my $loc_factory = new Bio::Factory::FTLocationFactory;
	  
	  my $prot_obj = $gp->get_Seq_by_id($protein_gi);
	  foreach my $feat ( $prot_obj->top_SeqFeatures ) {
	    if ( $feat->primary_tag eq 'CDS' ) {
	    # example: 'coded_by="U05729.1:1..122"'
	      my @coded_by = $feat->each_tag_value('coded_by');
	      my ($nuc_acc,$loc_str) = split /\:/, $coded_by[0];
	      my $nuc_obj = $gb->get_Seq_by_acc($nuc_acc);
	    # create Bio::Location object from a string
	      my $loc_object = $loc_factory->from_string($loc_str);
	    # create a Feature object by using a Location
	      my $feat_obj = new Bio::SeqFeature::Generic(-location =>$loc_object);
	    # associate the Feature object with the nucleotide Seq object
	    $nuc_obj->add_SeqFeature($feat_obj);
	    my $cds_obj = $feat_obj->spliced_seq;
	    print "CDS sequence is ",$cds_obj->seq,"\n";
	    }
	  }
	</code>
      </answer>
    </q>
    <q id="5">
      <question>How do I get the complete spliced nucleotide sequence from the CDS section?
      </question>
      <answer>
	<p>You can use the spliced_seq() method. For example:</p>
	<code>
	  my $seq_obj = $db->get_Seq_by_id($gi);
	  foreach my $feat ( $seq_obj->top_SeqFeatures ) {
	    if ( $feat->primary_tag eq 'CDS' ) {
	      my $cds_obj = $feat->spliced_seq;
	      print "CDS sequence is ",$cds_obj->seq,"\n";
	    }
	  }
	</code>
      </answer>
    </q>
    <q id="6">
      <question>How do I get the reverse-complement of a sequence using the subseq() method?</question>
      <answer>
	<p>One way is to pass the location to subseq() in the form of a Bio::Location object. This object holds strand information as well as coordinates.</p>
	<code>
	  use Bio::Location::Simple;
	  
	  my $location = new Bio::Location::Simple(-start  => $start,
                                           	   -end    => $end,
	                                           -strand => "-" );
	  # assume we already have a sequence object
	  my $rev_comp_substr = $seq_obj->subseq($location);
	</code>
      </answer>
    </q>
  </section>
  <section id="6">
    <section_name>Running external programs</section_name>
    <q id="1">
      <question>How do I run Blast from within Bioperl?</question>
      <answer> Use the module Bio::Tools::Run::StandAloneBlast.  It will give you access to many of the search tools in the NCBI blast suite including blastll, bl2seq, blastpgp.  The basic structure is like this.
	
	<code>use Bio::Tools::Run::StandAloneBlast;
	  my $factory = Bio::Tools::Run::StandAloneBlast->new(p => 'blastn',
	                                                      d => 'nt',
                                                              e => '1e-5');
	  my $seq = new Bio::PrimarySeq(-id => 'test1',
                                        -seq => 'AGATCAGTAGATGATAGGGGTAGA');
	  my $report = $factory->blastall($seq);
	</code>
      </answer>
    </q>
    <q id="2">
      <question>Hey, I want to run clustalw within Bioperl, I used Bio::Tools::Run::Alignment::Clustalw before - where did it go?</question>
      <answer>The Bio::Tools::Run directory was moved to a new package, bioperl-run, to help make the size of the core code smaller and separate out the more specialized nature of application running from the rest of Bioperl.  You can get these modules by installing the bioperl-run package.  This is either available from CVS under the same name or available in the http://bioperl.org/DIST directory and on CPAN.  This changeover began in the bioperl 1.1 developer release.
      </answer>
    </q>
    <q id="3">
      <question>What does the future hold for running applications within Bioperl?</question>
      <answer><p>We are trying to build a standard starting point for analysis application which will probably look like Bio::Tools::Run::AnalysisFactory which will allow the user to request which type of remote or local server they want to use to run their analyses.  This will connect to the Pasteur's PISE server, the EBI's Novella server, as well as be aware of wrappers to run applications locally.</p>
	<p>Additionally we suggest investigating the BioPipe project, also known as bioperl-pipeline, at <a href="http://www.biopipe.org">www.biopipe.org</a>. This is a sophisticated system to chain together sets of analyses and build rules for performing these computes.</p> 
      </answer>
    </q>
    <q id="3">
      <question>I'm trying to run StandAloneBlast and I'm seeing error messages like "Can't locate Bio/Tools/Run/WrapperBase.pm". How do I fix this?</question>
      <answer>
	<p>Yes, this file is missing in version 1.2. Two possible solutions: install version 1.2.1 or greater or retrieve and copy WrapperBase.pm to the proper location. You can get it at <a href="http://bio.perl.org/Bugs">http://bio.perl.org/Bugs</a>.</p></answer>
    </q>   
  </section>
  <copyright>Copyright (c)2002-2004 Open Bioinformatics Foundation. You may distribute this FAQ under the same terms as perl itself.</copyright>
</faq>
